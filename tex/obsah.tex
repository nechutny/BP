\listoftodos


\chapter{Úvod}
	Skriptovací jazyk PHP je velmi oblíbeným prostøedkem pro tvorbu dynamických webových systémù i pro rùzné skripty. Z~pùvodnì jednoduchého jazyka pro tvorbu stránek s~dynamickým obsahem vznikl jazyk se stovkami funkcí umo¾òující rychlou implementaci témìø jakékoliv úlohy.

	V~dùsledku pøesouvání mnoha slu¾eb do prostøedí webového prohlí¾eèe výraznì narùstá poèet a nároènost provádìných operací v~PHP. Od generování PDF souborù\footnote{\url{http://www.mpdf1.com/mpdf/index.php}}, pøes podepisování\footnote{\url{http://phpseclib.sourceforge.net/}} a komprimování souborù a¾ po nároèné operace jako je napøíklad detekování osob v~fotografiích\footnote{\url{https://github.com/mauricesvay/php-facedetection}} a podobnì. Právì takové knihovny jsou èasto psané v~PHP pro jednoduchost vývoje. PHP v¹ak umo¾òuje zavádìt roz¹íøení s~funkcemi v~nativním kódu, jejich¾ vykonávání je výraznì rychlej¹í.

	Pøevod knihoven v~PHP na ekvivalent v~jazyce C++ pøipravený pro zkompilování jako roz¹íøení PHP je cílem této práce. Zadání vychází ze skuteènosti, ¾e èastým zpùsobem vývoje aplikace je pou¾ití jedné konkrétní verze knihovny, v~které není tøeba provádìt úpravy. V~dùsledku pak výhody plynoucí z~interpretace nejsou tøeba, a naopak nevýhody znamenají propad výkonu.


	\section{Funkcionalita}
		Zamý¹lenou funkcionalitou je nástroj generující z~adresáøe se zdrojovými kódy v~jazyce PHP výstup v~jazyce C++. Výsledný kód by mìl implementovat stejnou funkcionalitu a zachovat alespoò podobnou souborovou strukturu. Po zkompilování výstupu vznikne dynamická knihovna (.so, èi .dll), kterou je mo¾né nastavit v~konfiguraci php prostøednictvím direktivy \function{extension}, èi naèíst bìhem interpretace vìstavìnou funkcí \function{dl()}.

		Takto transformované naètené funkce a tøídy bude mo¾né v~interpretovaném PHP pou¾ívat zcela stejnì jako v~pøípadì zdrojových - stejný zpùsob volání, stejné názvy, tøídy pùjde roz¹iøovat apod.

	\section{Motivace}
		Motivací pøi tvorbì této práce je urychlení webových aplikací napsaných v PHP. PHP umo¾òuje rychlý a levný vývoj, ale následné spou¹tìní je ji¾ pomalé. Pro zachování výhod rychlého vývoje a pohodlné tvorby zmìn byl navr¾en nástroj, který pøekládá pouze knihovny a nikoliv celou aplikaci.

		Modelový pøípad pou¾ití je pak tvorba PHP aplikace. Vývojáø chce pou¾ít knihovnu napøíklad pro detekci oblièeje ve fotografii. Jeliko¾ takovou knihovnu nechce upravovat, alea pouze pou¾ít nìkteré funkce z ní, tak mù¾e provést kompilaci pro její zrychlení. Knihovní funkce je pak vykonána rychleji a není naru¹ena mo¾nost rychlého a pohodlného vývoje aplikace. Tento koncept øe¹í nedostatky, na které nará¾elo podobné øe¹ení HPHPc navr¾ené spoleèností Facebook o kterém se zminuji v kapitole \ref{hphpc}.

	\section{Cíle}
		Cílem práce je navrhnout a implementovat pøekladaè funkcí zapsaných v podmno¾inì jazyka PHP, jeho¾ výstupem bude C++ kód doplnìný o potøebné konstrukce umo¾òující integraci do interpretru PHP.

		Podmno¾ina jazyka PHP byla vybrána po konzultaci s vedoucím práce a zamìøuje se primárnì na podporu výrazù a operací s promìnnými. Dále jsou podporovány základní konstrukce jako výpis hodnot, podmínky, cykly, funkce. Podrobnìjí jsou tyto konstrukce rozebrány v kapitole \ref{constructions}.

		Po implementaci pøekladaèe pro po¾adovaný rozsah se zamìøím na jeho testování a hledání slabých míst. Následnì se pokusím najít konstrukce, která nefungují korektnì, èi jsou pomalé a navrhnout øe¹ení. Tento krok bude proveden opakovanì po realizaci navrhnutých øe¹ení.



\chapter{Konkurenèní øe¹ení}
	Provedl jsem analýzu souèasných konkurenèních øe¹ení a nepodaøilo se mi nalézt nástroj implementující takovouto funkcionalitu. Funkcionalitou podobný je nástroj phc\footnote{\url{http://www.phpcompiler.org/}}, který slou¾í primárnì pro kompilaci PHP kódu do spustitelných binárních souborù, které nepotøebují interpret. Dal¹ím podobným a z~technického hlediska zajímavým øe¹ením je HPHPc od spoleènosti Facebook, kterým se budu zabývat v~následující podkapitole a poslou¾í i jako zajímavá inspirace øe¹ení.

	\section{phc}
		Phc je kompilátor podmno¾iny jazyka PHP do spustitelných binárních souborù. Odstraòuje závislost na interpretru PHP a tak umo¾òuje pohodlnou distribuci cli skriptù. Vývoj tohoto nástroje zapoèali v~roce 2005 vývojáøi Edsko de Vries a John Gilbert. Postupnì se do vývoje zapojilo na 21 vývojáøù a poslední verze byla vydána v~roce 2011\cite{PhcContributing}. Od té doby se pouze mno¾í chybové reporty a projekt není udr¾ován\cite{PhcIssues}.

		Nástroj podporoval také funkcionalitu, která je cílem této bakaláøské práce a bylo tedy mo¾né transformovat PHP knihovny do roz¹íøení pro následné pou¾ití v~PHP. Dle dokumentace na webu projektu nebyla v¹ak podpora pro objektové programování a chybìla implementace novìj¹ích jazykových konstrukcí\cite{PhcContributing}.

		S~nejstar¹í v~souèasné dobì podporovanou verzí PHP ji¾ není mo¾né aplikaci ani pøelo¾it i pøes mnohé pokusy o~úpravy zdrojových kódù pro zaji¹tìní kompatibility.

		\todo[inline]{Kontaktován Paul Biggar (jeden z~vývojáø). Pokud bude ochotný odpovìdìt, tak se zeptat:
			1) Jaký byl stav a plány do budoucna
			2) Proè do¹lo k~ukonèení projektu a jaké byly jeho dùvody
			3) Vidí i dnes v~tomto konceptu potenciál
			4) Co by mohlo být pøeká¾kou}


	\section{HPHPc}\label{hphpc}
		Tento projekt od spoleènosti Facebook byl zapoèat v~roce 2008 a mìl za cíl sní¾it výkonnostní nároky aplikací psaných v~PHP. To se také vývojáøskému týmu podaøilo a dosáhli sní¾ení vytí¾ení procesoru na polovinu\cite{HipHopMoveFast}. V~roce 2010 do¹lo k~uvolnìní zdrojových kódù projektu pod licencí PHP License a umo¾nìní zapojení komunity do vývoje. V ruce 2013 do¹lo k ukonèení tohoto projektu a nahrazení nástupcem Hip Hop Virtual Machine (HHVM).

		\begin{wrapfigure}{r}{0.45\textwidth}
			\centering
			\includegraphics[width=0.45\textwidth]{comparison}
			\caption{Drupal 7.0 na PHP 5.3, APC a Hip Hop\cite{PhpDrupal}}
			\label{fig:hipHopDrupal}
		\end{wrapfigure}

		Testy provedené v~dubnu 2011 ukazují na velký potenciál pøekladu PHP do nativního kódu\cite{hipHopBechmark}. Napøíklad práce s~binárními stromy do hloubky 20 úrovní byla dle mìøení 4x rychlej¹í. Zajímavìj¹í byl ov¹em test Hip Hop na pøekladu redakèního systému Drupal 7. Tento test ukázal na reálné aplikaci pìtinásobné zrychlení oproti PHP 5.3.3\cite{PhpDrupal}. Graf porovnávající Drupal 7 pod PHP 5.3.3, pou¾ití opcode cache APC a Hip HOP revize 806ee06 mù¾eme vidìt na obrázku \ref{fig:hipHopDrupal}. Na grafu je zobrazeno procentuální vytí¾ení procesoru a doba zpracování 300 po¾adavkù s konkurencí 4.

		HPHPc provádìlo kompilaci celých PHP aplikací do jednoho velkého spustitelného binárního souboru. Nasazování nových verzí tak bylo zpomaleno o~kompilaci a distribuci a¾ nìkolik GB velkých souborù na produkèní servery. Jedná se tedy o~jiné cílové pou¾ití, ne¾ na jaké se zamìøuje tato práce. Nebylo mo¾né vyu¾ít výhod verzovacích systémù, kdy jsou distribuovány jen malé rozdíly v~souborech a v~neposlední øadì nebyla podpora pro nìkteré dynamické konstrukce jako napøíklad \function{eval()}. Hlavní nevýhodou tohoto øe¹ení byl problémový vývoj aplikace. Vývojáø by byl nucen po ka¾dé zmìnì provádìt kompilaci, co¾ by bylo èasovì nároèné u takto rozsáhlé aplikace. V dùsledku této komplikace vznikla implementace vlastního interpretru pou¾ívajícího stejné implementace funkcí HPHPi, ale i tak docházelo k výskytu chyb na produkèních serverech, které se u vývojáøù neobjevovali. Dùvodem bylo rozdílné prostøedí. V~dùsledku tìchto nevýhod bylo rozhodnuto, ¾e se projekt vydá cestou JIT (Just in time) virtuálního stroje\cite{HipHopSpeeding}, který vyu¾ívá bytecode generovaný ze zdrojových kódù PHP, jako mù¾eme znát tøeba z~jazyka Java.


		\begin{wrapfigure}{r}{0.35\textwidth}
			\centering
			\includegraphics[width=0.35\textwidth]{hphpc_hhvm}
			\caption{Srovnání rychlosti HPHPc a HHVM\cite{HipHopSpeeding}}
			\label{fig:hipHopSpeedGraph}
		\end{wrapfigure}
		Po sedmi mìsících vývoje dosáhla implementace HHVM (Hip Hop Virtual Machine) lep¹í výsledkù, ne¾ HPHPc a 19. února 2013 byla commitem odebrána ze zdrojových kódù podpora pro kompilování HPHPc\cite{HipHopRemoveCompiler}. Na grafu \ref{fig:hipHopSpeedGraph} mù¾eme vidìt srovnání výkonu obou implementací v prùbìhu èasu.

		Øe¹ení, které je navr¾eno a implementováno v této práci ponechává mo¾nost pohodlné zmìny aplikace a cílí na pøeklad jednotlivých knihoven/funkcí. Klasický vývojový cyklus zahrnuje pou¾ití knihovny, z které jsou pouze volány funkce a není tøeba provádìt její úpravy. Mé øe¹ení odstraòuje potí¾e vzniklé s kompilací pøi vývoji, nebo dvojím prostøedím, u øe¹ení HPHPc.


	\section{Roadsend PHP}
		\todo[inline]{Rozepsat Roadsend PHP}

		\url{http://www.roadsend.com/}

\chapter{Vybrané konstrukce PHP}\label{constructions}
	Vkládání prostøednictvím konstrukcí \function{include}, \function{require} a jejich variant pro unikátní vlo¾ení bude z~dùvodu komplexnosti implementováno jen v~omezené míøe. Prvním logickým omezením vycházejícím z~návrhu tohoto nástroje je schopnost provést vlo¾ení pouze souborù, které jsou dostupné v~momentì pøekladu a jejich¾ cesta je známá. Nebude tedy mo¾ná transformace funkce \function{includeNe} uvedené v~kódu \ref{code:phpIncludeFunction}, ani funkce \function{includeNe2} i v~pøípadì existence souborù \function{prvni.php} a \function{druhy.php}.

	Druhým omezením vkládání souborù je pouze èásteèná implementace varianty \function{include\_once} a \function{require\_once}, kdy nebude mo¾né zcela zajistit neopakované vlo¾ení v~dobì bìhu aplikace. V~dobì transformace PHP do C++ bude toto chování kontrolováno a dojde pouze k~prvnímu vlo¾ení. V~dobì vykonávání zkompilované funkce v~prostøedí interpretru PHP v¹ak nebude mo¾né zamezit vlo¾ení, jeliko¾ systém roz¹íøení PHP neumo¾nuje ovlivòovat tyto èásti.

\begin{lstlisting}[caption=Vlo¾ení souboru, label=code:phpIncludeFunction, language=PHP]
function includeNe($soubor)
{
	include $soubor;
}

function includeNe2($co)
{
	$soubor = $co ? "prvni.php" : "druhy.php";

	include $soubor;
}
\end{lstlisting}

	Dal¹í implementovanou èástí je podpora konstrukcí \function{echo}, \function{exit} a dal¹í uvedené v~tabulce \ref{table:phpTokenConstruction}.

		\begin{center}
			\begin{tabular}{ | l | l | l |} \hline

				Typ			&	Token				& Zápis \\
				\hline
				\hline
				Komentáø	&	T\_COMMENT			&	\function{\slash\slash}, \function{\#}, \function{\slash* ... *\slash}	\\
							&	T\_DOC\_COMMENT		&	\function{\slash** ... *\slash} \\
				\hline
				Výstup		&	T\_PRINT			&	\function{print()} \\
							&	T\_ECHO				&	\function{echo} \\
				%			&	T\_INLINE\_HTML		&	\function{?\textgreater ... html ... \textless?php} \\
				\hline
				Vkládání	&	T\_INCLUDE			&	\function{include} \\
							&	T\_INCLUDE\_ONCE	&	\function{include\_once} \\
							&	T\_REQUIRE			&	\function{require} \\
							&	T\_REQUIRE\_ONCE	&	\function{require\_once} \\
				%\hline
				%			&	T\_LIST				&	\function{list()} \\
				\hline
				Ukonèení	&	T\_EXIT				&	\function{exit()}, \function{die()} \\
				\hline
				Názvy		&	T\_STRING			&	funkce, konstanty... \\
				\hline
				Promìnné	&	T\_VARIABLE			&	\function{\$a} \\
				\hline
			\end{tabular}

			\captionof{table}{Tabulka tokenù konstrukcí}
			\label{table:phpTokenConstruction}
		\end{center}


		PHP umo¾nuje pøistoupit k promìnné, její¾ název je ulo¾en v jiné promìnné prostøednictvím konstrukce \function{\$\$promenna}, nebo \function{\$\{\$promenna\}}. Tento zápis v souèasné implementaci nebude podporován, jeliko¾ je tøeba omezit implementovaný rozsah a jedná se o potencionálnì nebezpeènou konstrukci, stejnì jako konstrukce \function{extract()}\cite{PhpExtract}.

		Pøi transformaci je podporován zápis konstant ve zdrojových souborech. Podporovaný je zápis èísel v~celoèíselném i desetinném formátu. Na základì tìchto typù je pøihlédnuto k~volbì datových typù ve výstupním kódu. Dále je pak podporován zápis øetìzcù i s~mo¾ností pou¾ití promìnných. Podporované tokeny pak podrobnìji ukazuje tabulka \ref{table:phpTokenConstant}

		Øetìzce je mo¾né konkatenovat s èísly, poli a dal¹ími hodnotami. Tato funkcionalita prostøednictvím operátoru \function{.} je implementována. Dále se v øetìzcích uvozených prostøednictvím znaku \function{"} mohou vyskytovat vlo¾ené promìnné, s pøípadném pøístupem k indexu pole. Tento zápis (tokeny T\_ENCAPSED\_AND\_WHITESPACE a T\_NUM\_STRING) ji¾ nejsou podporovány z dùvodu volby podmno¾iny jazyka.

		\begin{center}
			\begin{tabular}{ | l | l | l |} \hline

				Typ					&	Token							& Zápis \\
				\hline
				\hline
				Desetinné èíslo		&	T\_DNUMBER						& \function{1.2345} \\
				\hline
				Celé èíslo			&	T\_LNUMBER						& \function{93}, \function{0xC0FFEE} \\
				\hline
				Øetìzec				&	T\_CONSTANT\_ENCAPSED\_STRING	& \function{"retezec"} \\
				\hline
				Promenná v~øetìzci	&	T\_ENCAPSED\_AND\_WHITESPACE	& \function{"\$a"} \\
				\hline
				Pole v~øetìzci		&	T\_NUM\_STRING					& \function{"\$a[0]"} \\
				\hline
			\end{tabular}
			\captionof{table}{Tabulka tokenù konstant}
			\label{table:phpTokenConstant}
		\end{center}

		%	\begin{itemize}
		%		\item T\_ARRAY					\function{array()}
		%		\item T\_DOUBLE\_ARROW			\function{=\textgreater}
		%	\end{itemize}

		Stì¾ejní èástí aplikace je vyhodnocování výrazù. Pro implementaci byly zvoleny v¹echny tokeny pro matematické operace, porovnávání, bitové posuvy i pøetypování viz tabulka \ref{table:phpTokenExpresion}.

		\begin{center}
			\begin{tabular}{ | l | l | l |} \hline

				Typ					&	Token							& Zápis \\
				\hline
				\hline
				Porovnání			& T\_IS\_EQUAL						& \function{==} \\
									& T\_IS\_NOT\_EQUAL					& \function{!=}, \function{\textless\textgreater} \\
									& T\_IS\_IDENTICAL					& \function{===} \\
									& T\_IS\_NOT\_IDENTICAL				& \function{!==} \\
									& T\_IS\_GREATER\_OR\_EQUAL			& \function{\textgreater=} \\
									& T\_IS\_SMALLER\_OR\_EQUAL			& \function{\textless=} \\
									& T\_SPACESHIP						& \function{\textless=\textgreater} \\
				\hline
				Pøiøazení			& T\_AND\_EQUAL						& \function{\&=} \\
									& T\_CONCAT\_EQUAL					& \function{.=} \\
									& T\_DIV\_EQUAL						& \function{\slash=} \\
									& T\_MINUS\_EQUAL					& \function{-=} \\
									& T\_MOD\_EQUAL						& \function{\%=} \\
									& T\_MUL\_EQUAL						& \function{*=} \\
									& T\_OR\_EQUAL						& \function{$|$=} \\
									& T\_PLUS\_EQUAL					& \function{+=} \\
									& T\_POW\_EQUAL						& \function{**=} \\
									& T\_SL\_EQUAL						& \function{\textgreater\textgreater=} \\
									& T\_SR\_EQUAL						& \function{\textless\textless=} \\
									& T\_XOR\_EQUAL						& \function{\textasciicircum=} \\
				\hline
				Logické èleny		& T\_BOOLEAN\_AND					& \function{\&\&} \\
									& T\_BOOLEAN\_OR					& \function{$||$} \\
									& T\_LOGICAL\_AND					& \function{and} \\
									& T\_LOGICAL\_OR					& \function{or} \\
									& T\_LOGICAL\_XOR					& \function{xor} \\
				\hline
				Bitové posuvy		& T\_SL								& \function{\textgreater\textgreater} \\
									& T\_SR								& \function{\textless\textless} \\
				\hline
				Matematické operace & T\_POW							& \function{**} \\
									& T\_DEC							& \function{$--$} \\
									& T\_INC							& \function{$++$} \\
				\hline
				Pøetypování			& T\_ARRAY\_CAST					& \function{(array)} \\
									& T\_BOOL\_CAST						& \function{(bool)} \\
									& T\_INT\_CAST						& \function{(int)} \\
									& T\_DOUBLE\_CAST					& \function{(real)}, \function{(float)}, \function{(double)} \\
									& T\_OBJECT\_CAST					& \function{(object)} \\
									& T\_STRING\_CAST					& \function{(string)} \\
				\hline
				% \item T\_EMPTY			\function{empty()}
				% \item T\_ISSET			\function{isset()}
			\end{tabular}
			\captionof{table}{Tabulka tokenù výrazù}
			\label{table:phpTokenExpresion}
		\end{center}

		Dal¹í podstatnou èástí podmno¾iny je podpora øídících konstrukcí. Podporovanými výrazy je zápis podmínek i cyklù. Z cyklù je podporovaný \function{for}, \function{while}, \function{do while} i \function{foreach}, který slou¾í pro iteraci nad v¹emi prvky v poli. Jednotlivé tokeny jsou uvedeny v tabulce \ref{table:phpTokenControl}.

		\begin{center}
			\begin{tabular}{ | l | l | l |} \hline

				Typ					&	Token							& Zápis \\
				\hline
				\hline
				Podmínka			& T\_IF								& \function{if} \\
									& T\_ELSE							& \function{else} \\
									& T\_ELSEIF							& \function{elseif} \\
									& T\_ENDIF							& \function{endif} \\
				\hline
				Cykly				& T\_DO								& \function{do} \\
									& T\_WHILE							& \function{while} \\
									& T\_ENDWHILE						& \function{endwhile} \\
									& T\_FOR							& \function{for} \\
									& T\_ENDFOR							& \function{endfor} \\
									& T\_FOREACH						& \function{foreach} \\
									& T\_AS								& \function{as} \\
									& T\_ENDFOREACH						& \function{endforeach} \\
									& T\_BREAK							& \function{break} \\
									& T\_CONTINUE						& \function{continue} \\
				\hline
				\end{tabular}
			\captionof{table}{Tabulka tokenù øídících konstrukcí}
			\label{table:phpTokenControl}
		\end{center}

	\section{Funkce}
		Podpora definice funkcí s~i bez návratové hodnoty. Podpora argumentù, nepovinné argumenty s~výchozí hodnotou.

		\begin{itemize}
			\item T\_FUNCTION		\function{function}

			%\item T\_ELLIPSIS		\function{...}

			\item T\_RETURN			\function{return}
		\end{itemize}

	\section{Tøídy}

		V dùsledku udr¾ení rozumného rozsahu podmno¾iny byla vypu¹tìna objektovì orientovaná èást konstrukcí jazyka. Není tedy mo¾né v pøekladém kódu definovat ani vytváøet instance tøíd, dìdit, implementovat interface. Nejsou podporovány logicky ani jmenné prostory, modifikátory viditelnosti a statické metody. Pro úplnost uvádím tabulku nepodporovaných tokenù \ref{table:phpTokenClass}. Podpora OOP èásti jazyka je v¹ak plánována v budoucnu.

		\begin{center}
			\begin{tabular}{ | l | l | l |} \hline

				Typ					&	Token							& Zápis \\
				\hline
				\hline
				Definice			& T\_CLASS							& \function{class} \\
									& T\_EXTENDS						& \function{extends} \\
									& T\_IMPLEMENTS						& \function{implements} \\
				\hline
				Konstanta			& T\_CONST							& \function{const} \\
									& T\_INTERFACE						& \function{interface} \\
				\hline
				Namespace			& T\_NAMESPACE						& \function{namespace} \\
									& T\_NS\_SEPARATOR					& \function{$\backslash$} \\
									& T\_USE							& \function{use} \\
									& T\_NEW							& \function{new} \\
				\hline
				Modifikátory		& T\_PRIVATE						& \function{private} \\
									& T\_PUBLIC							& \function{public} \\
									& T\_PROTECTED						& \function{protected} \\
									& T\_STATIC							& \function{static} \\
				\hline
				Pøístup				& T\_DOUBLE\_COLON					& \function{::} \\
									& T\_OBJECT\_OPERATOR				& \function{-\textgreater} \\
				\hline

			\end{tabular}
			\captionof{table}{Tabulka tokenù tøíd}
			\label{table:phpTokenClass}
		\end{center}



\chapter{Rozdíly PHP a C++}
	Rozdílù mezi obìmi jazyky je celá øada i pøes jejich velkou podobnost a je tøeba se s~nimi vypoøádat.

	\section{Výrazy}
		Tabulka \ref{table:phpPrecendenceTable} na stranì \pageref{table:phpPrecendenceTable} obsahuje operátory jazyka PHP s~jejich asociativitou seøazené dle priority - priorita se sni¾uje shora dolù. Druhou podstatnou tabulkou je \ref{table:cppPrecendenceTable} na stranì \pageref{table:cppPrecendenceTable}, která obsahuje priority a asociativitu operátorù jazyka C++. Priorita je opìt seøazena od nejvy¹¹í po nejni¾¹í. Pøi podrobnìj¹ím prozkoumání tabulky narazíme na nìkolik rozdílù, se kterými se je tøeba vypoøádat.

		Prvním je absence operátoru konkatenace \function{.} ze~zdrojového jazyka PHP ve výsledném C++. Dále chybí operátor mocniny \function{**}.

		Dal¹ím chybìjícím operátorem je \function{@}, který slou¾í pro potlaèení pøípadného chybového výstupu. Jeho pou¾ití je v~kódu PHP nedoporuèované\cite{PhpErrorSupress1} \cite{PhpErrorSupress2} \cite{PhpErrorSupress3} \cite{PhpErrorSupress4} i pøesto je mo¾né provést implementaci tohoto chování, èím¾ se zabývám v~kapitole \ref{potlaceniChyby} na stranì \pageref{potlaceniChyby}.

		Logické operátory \function{OR}, \function{AND}, \function{XOR} v PHP a \function{||}, \function{\&\&}, \function{\textasciicircum\textasciicircum} v C++ mají rozdílnou prioritu. Proto byla v kapitole \ref{logOp} navr¾ena transformace s explicitním závorkováním.

		\subsection{Porovnávání}
			Rozdíl v~porovnávání promìnných v~jazycích, kterými se zabývá tato práce je pomìrnì zásadní. Zdrojový jazyk obsahuje dva typy porovnání, kdy je mo¾né porovnávat odli¹né datové typy. Konstrukce \function{\textquotedbl5\textquotedbl == 5} pak bude v~PHP pravdivá, kde¾to v~C++ nikoliv. Pro porovnání i s~pøihlédnutím k~typu je v~PHP operátor \function{===} \cite{PhpCompareOperator}.

			Problematickým chováním mù¾e být pøetypovávání pøi porovnání. Nejen, ¾e v~pøípadì, ¾e jeden z~operandù porovnání je èíslo mù¾e dojít k~pøetypování druhého operandu typu øetìzec na èíslo, ale i v~pøípadì porovnávání dvou øetìzcù, které mohou mít význam èísla. Napøíklad v~PHP je pravdivé toto porovnání \function{'1e3' == '1000'} \cite{PhpCompareStrict} \cite{PhpCompareHash}.

			Porovnávání instancí tøíd prostøednictvím operátoru \function{==} je pravdivé, pokud jsou instancemi stejných tøíd a v¹echny jejich vlastnosti mají stejnou hodnotu. Pøi porovnání \function{===} je porovnání pravdivé jen v~pøípadì toto¾ných instancí \cite{PhpCompareObject}.


			\cite{PhpCompareTable}


			\begin{center}
  				\begin{tabular}{ | l | l | l |}
					\hline
					Asociativita	& Operátor																						& Dal¹í informace			\\ \hline
					\hline
					neasociativní	& clone, new																					& clone a new				\\ \hline
					levá			& [																								& Pole						\\ \hline
					pravá			& **																							& Výpoèet					\\ \hline
					pravá			& ++, --, (int), (float), (string),																& (in/de)krementace, typy,	\\
									& (array), (object), (bool), @																	& uti¹ení chyby				\\ \hline
					neasociativní	& instanceof																					& Typy						\\ \hline
					pravá			& !																								& Logické výrazy			\\ \hline
					levá			& *, /, \%																						& Výpoèet					\\ \hline
					levá			& +, -, .																						& Výpoèty a øetìzec			\\ \hline
					levá			& \textless \textless, \textgreater \textgreater												& Bitové operace			\\ \hline
					neasociativní	& \textless, \textless=, \textgreater, \textgreater=											& Porovnání					\\ \hline
					neasociativní	& ==, !=, ===, !==, \textless\textgreater, \textless=\textgreater								& Porovnání					\\ \hline
					levá			& \&																							& Bitové operace a reference\\ \hline
					levá			& \textasciicircum																				& Bitové operace			\\ \hline
					levá			& $|$																							& Bitové operace			\\ \hline
					levá			& \&\&																							& Logické výrazy			\\ \hline
					levá			& $||$																							& Logické výrazy			\\ \hline
					pravá			& ??																							& Porovnání					\\ \hline
					levá			& ?:																							& Porovnání					\\ \hline
					pravá			& =, +=, -=, *=, **=, /=, .=,																	& Pøiøazení					\\
									& \%=, $|$=, \textasciicircum=, \textless\textless=, \textgreater\textgreater=, =\textgreater	&							\\  \hline
					levá			& and																							& Logické výrazy			\\ \hline
					levá			& xor																							& Logické výrazy			\\ \hline
					levá			& or																							& Logické výrazy			\\ \hline
					levá			& ,																								& Mnoho významù				\\ \hline
  				\end{tabular}
  				\captionof{table}{Tabulka priority výrazù PHP\cite{PhpPrecendence}}
				\label{table:phpPrecendenceTable}
			\end{center}

			\begin{center}
  				\begin{tabular}{ | l | l | l |}
					\hline
					Asociativita	& Operátor											& Dal¹í informace											\\ \hline
					\hline
					levá			& ::												& Scope resolution											\\ \hline
					pravá			& ++, --											& Prefix inkrementace a dekrementace						\\
									& +, -												& Unární plus a mínus										\\
									& !, \~												& Logická negace a binární negace							\\
									& (type)											& Pøetypování (C styl)										\\
									& *													& Dereference												\\
									& \&												& Reference													\\
									& sizeof											& Size-of													\\
									& new												& Vytvoøení instance										\\
									& delete											& Zru¹ení instance											\\ \hline
					levá			& ., -\textgreater									& Ukazatel na èlena											\\ \hline
					levá			& *, /, \%											& Násobení, dìlení, zbytek po celoèíselném dìlení			\\ \hline
					levá			& +, -												& Sèitání a odèítání										\\ \hline
					levá			& \textless\textless, \textgreater\textgreater		& Bitový posuv vlevo a vpravo								\\ \hline
					levá			& \textless, \textless=								& Porovnání - men¹í, men¹í nebo rovno						\\
									& \textgreater, \textgreater=						& Porovnání - vìt¹í, vìt¹í¹í nebo rovno						\\ \hline
					levá			& ==, !=											& Porovnání - rovno, nerovno								\\ \hline
					levá			& \&												& Bitový AND												\\ \hline
					levá			& \textasciicircum									& Bitový XOR (exkluzivní OR)								\\ \hline
					levá			& $|$												& Bitový OR													\\ \hline
					levá			& \&\&												& Logický AND												\\ \hline
					levá			& $||$												& Logický OR												\\ \hline
					pravá			& ?:												& Ternární operátor											\\
									& throw												& Operátor výjimky											\\
									& =													& Pøímé pøiøazení											\\
									& +=, -=											& pøiøazení souètem/odeètem									\\
									& *=, /=, \%=										& Pøiøazení násobku, dìlení, zbytku po celoèíselném dìlení	\\
									& \textless\textless=, \textgreater\textgreater=	& Pøiøazení výsledku bitového posuvu vlevo/vpravo			\\
									& \&=, \textasciicircum=, $|$=						& Pøiøazení bitového AND, XOR, OR							\\ \hline
					Levá			& ,													& Èárka - mnoho významù										\\ \hline


				\end{tabular}
				\captionof{table}{Tabulka priority výrazù C++\cite{CppPrecendence}}
				\label{table:cppPrecendenceTable}
			\end{center}

	\section{Promìnné}
		Rozdílný obor platnosti promìnných uvnitø blokù v~PHP a C++

		Nutnost vytahnout deklaraci promìnné mimo bloky cyklù, pokud je s~nimi pracováno i za blokem.

		\todo[inline]{Ovìøit kompatabilitu jmen}

	\section{Funkce}
		\todo[inline]{Ovìøit kompatabilitu jmen}



\chapter{Integrace do PHP}
	\label{integrateToPhp}
	\todo[inline]{rozebrat fungování roz¹íøení v~php, definice funkcí, tøíd. Ponoøení do Zend Engine...}

	Interpret PHP umo¾òuje zavádìt dynamické knihovny tzv. moduly, které roz¹iøují dostupné funkce a tøídy v~interpretovaném prostøedí. Naètení je mo¾né prostøednictvím konfiguraèní direktivy \function{extension=nazev.so} v~konfiguraèním souboru \function{php.ini}, èi v~dobì bìhu funkcí \function{dl("nazev.so")}. Roz¹íøení obsahují tzv. entry point, tedy místo kam v~momentì po¾adavku na naètení modulu skoèí tok interpretru a oèekává se vrácení datové struktury, která obsahuje informace o~dostupných funkcích a tøídách. Zend Engine, jádro PHP, je napsáno primárnì v~jazyce C, tak¾e je tøeba dodr¾et kompatibilní zpùsob volání a navrácení výsledku. V~pøípadì této práce bude z~dùvodu jazyka C++ nutno pou¾ít konstrukci \function{extern "C"}.

	Struktura \function{zend\_module\_entry} obsahuje následující hodnoty\cite{PhpExtensionStructure}:

	\begin{itemize}
		\item
			Verze Zend API, pro kterou je modul zkompilován.
		\item
			Seznam závislostí modulu na jiných modulech.
		\item
			Název modulu.
		\item
			Ukazatel na pole struktur se seznamem funkcí (\function{zend\_function\_entry}).
		\item
			Ukazatel na funkci volanou pøi zavedení modulu.
		\item
			Ukazatel na funkci volanou pøi ru¹ení modulu.
		\item
			Ukazatel na funkci volanou pøi ka¾dém pøíchozím po¾adavku na stránku (pøi pou¾ití PHP jako SAPI modul webového serveru Apache).
		\item
			Ukazatel na funkci volanou pøi konci po¾adavku na stránku.
		\item
			Funkce vracející informace pøi volání \function{phpinfo()}.
		\item
			Verze modulu.
		\item
			Globální promìnné modulu.
	\end{itemize}

	Struktura \function{zend\_function\_entry} pak obsahuje\cite{PhpExtensionFunctionStructure}:

	\begin{itemize}
		\item
			Jméno, pod jakým bude funkce dostupná v~PHP.
		\item
			Ukazatel na funkci.
		\item
			Argumenty funkce - zda mají být pøedány referencí.
	\end{itemize}

	\begin{figure}[h]
		\centering
		\includesvg[svgpath = img/]{PhpExtensionLifeCycleDiagram}
		\caption{®ivotní cyklus roz¹íøení}
		\label{PhpExtensionLife}
	\end{figure}




\chapter{Návrh transformace}

	\section{Porovnání}
		compare\_function(result, a, b TSRMLS\_CC);

	\section{Operátory}
		...

		\subsection{Konkatenace}
			\function{std::string} obsahuje metodu \function{append}\cite{cppStringAppend}. Je tedy mo¾né transformovat kód \ref{code:phpConcatenation} na \ref{code:cppConcatenation}.

			\begin{lstlisting}[caption=PHP ukázka konkatenace, label=code:phpConcatenation, language=PHP]
$a = "a";
$b = "b";
$a .= $b;
			\end{lstlisting}



			\begin{lstlisting}[caption=Transformace konkatenace, label=code:cppConcatenation, language=Cpp]
std::string a = "a";
std::string b = "b";
a.apend(b);
			\end{lstlisting}

		\subsection{Mocnina}
			Pro výpoèet mocniny èísla je mo¾né nahradit operátor \function{**} za volání funkce \function{pow} ze standardní knihovny \function{math.h}\cite{CppMathPow}.

		\subsection{Logické operátory}\label{logOp}
			Jak je uvedeno v tabulce \ref{table:phpPrecendenceTable} priorit výrazù PHP na stranì \pageref{table:phpPrecendenceTable}, tak jazyk PHP obsahuje pro logické operace dvì mo¾nosti zápisu operací. Prvním zpùsobem zápisu s vy¹¹í prioritou je zápis prostøednictvím operátorù \function{\&\&}, \function{$||$} a \function{\textasciicircum}. Tento zápis má vy¹¹í prioritu, ne¾ pøiøazení. Pøi zápisu v kódu \ref{code:phpOperatorPrecedence} na první øádce tedy bude výsledná hodnota v promìnné \function{\$a} nepravdivá. Opakem je v¹ak zápis na øádku 2, kdy bude hodnota promìnné pravdivá, jeliko¾ se s vy¹¹í prioritou provede pøiøazení a a¾ s výsledkem pøiøazení se provede AND, jeho¾ výsledek se zahodí.

			\begin{lstlisting}[caption=PHP ukázka rozdílných priorit operátorù, label=code:phpOperatorPrecedence, language=PHP]
$a = TRUE &&  FALSE; //  $a = (TRUE AND FALSE)  -> $a == FALSE
$a = TRUE AND FALSE; // ($a = TRUE) AND FALSE   -> $a == TRUE
			\end{lstlisting}

			Jazyk C++ v¹ak obsahuje pouze operátory s vy¹¹í prioritou, ne¾ pøiøazení. Kromì priority operátorù se chování neli¹í\cite{PhpLogicOperators}. Je tedy tøeba kromì nahrazení zápisu ve formì slova za funkènì odpovídající zápis z jazyka C++ také provést uzavøení levé a pravé strany do závorek.

			Výsledná transformace tedy bude \function{\textless výraz \textgreater OR \textless výraz \textgreater $\rightarrow$ ( \textless výraz \textgreater ) $||$ ( \textless výraz \textgreater )}

		\subsection{Dìlení}
			V pøípadì dìlení èísel v PHP se neprovádí celoèíselné, ale i pro výraz \function{5/4} je výsledkem desetinné èíslo. Pøi transformaci operátorù dìlení bude tedy tøeba provést zmìnu typu na float/double. V jazyce C++ je rozdíl mezi výrazy \function{5/4} a \function{5.0/4.0}, kdy v prvním pøípadì je výsledkem \function{1} a v druhém \function{1.2}. Pøi transformaci tedy bude tøeba oba operátory dìlení pøetypovat na desetinné èíslo.


		\subsection{Potlaèení chyby}
			\label{potlaceniChyby}
			Bude tøeba èást s~potlaèenou chybou vyjmout do vlastní èásti kódu, pøiøadit výsledek do pomocné promìnné a obalit voláním funkcí z~jádra PHP viz kód \ref{code:supressError} na stranì \pageref{code:supressError}.

			\begin{lstlisting}[caption=Potlaèení chybové hlá¹ky\cite{PhpErrorSupress2}, label=code:supressError, language=Cpp]
void zend_do_begin_silence(znode *strudel_token TSRMLS_DC);
// volaný kód
void zend_do_end_silence(const znode *strudel_token TSRMLS_DC);
			\end{lstlisting}

			\todo[inline]{Jak se odkazovat na zdrojové kódy z~rùzných projektù?}


\chapter{Implementace}
	Pro implementaci byl zvolen jazyk PHP, v kterém je mo¾né provádìt rychle implementaci a poskytuje potøebné funkce. Velkou výhoou pro implementaci je \function{token\_get\_all()}, která umo¾òuje naparsovat zdrojový kód a pøevést jej na tokeny. Po získání tokenù je provedena analýza rekurzivním sestupem zhora dolu. Pøi analýze je generován abstraktní syntaktický strom pro generátor kódu. Parser vyu¾ívá volání precedenèní analýzy, která provádí kontrolu výrazù a provádí také tvorbu derivaèního stromu, kterého je následnì vyu¾ito pro tvorbu abstraktního syntaktického stromu výrazù. Po získání v¹ech potøebných informací ze zdrojového kódu je pøistoupeno k analýze výrazù pro detekci datových typù a následnì provedeno generování C++ kódu.

	Prvnì jsem provedl analýzu nìkolika hotových øe¹ení parsování zdrojových kódù, ale zjistil jsem, ¾e rychlej¹ím a pohodlnìj¹ím pro dal¹í vývoj bude tvorba vlastního øe¹ení. Prozkoumaná øe¹ení byla èasto velmi obecná pro pokrytí co nevìt¹í èásti jazyka PHP a nedetekovala pak nìkteré chybnné konstrukce. Dále pak jejich výstup neobsahoval dostatek potøebných informací pro urèování datových typù a vhodné sestavování C++ kódu. Mezi zkoumanými øe¹eními bylo i PHP-Parser\footnote{\url{https://github.com/nikic/PHP-Parser}}, jeho¾ autorem je Nikita Popov, který také pøispívá do PHP interpretru a je jedním z autorù knihy \uv{PHP Internals Book} zabývající se tvorbou PHP roz¹íøení. Zajímavým a vhodným øe¹ením s dobrým výstupem se ukázal PHP Analyzer\footnote{\url{https://scrutinizer-ci.com/docs/tools/php/php-analyzer/}} od spoleènosti Scrutinizer, který provádí velmi podrobnou analýzu. Problémem v¹ak byla vysoká cena komplikující zámìø poskytnout výsledné øe¹ení jako open source produkt dostupný zdarma.


	\section{Knihovny}
		Pøi implementaci jsem se rozhodl pou¾ít open source knihovny poskytující nìkteré potøebné funkce, ne¾ aby docházelo k jejich opakované tvorbì.

		\subsection{PHP-CPP}
			PHP-CPP\footnote{\url{http://www.php-cpp.com/}} je knihovna od spoleènosti Copernica, která umo¾òuje tvorbu roz¹íøení PHP v jazyce C++ a pøidává abstrakci nad interními Zend strukturami. Knihovna je ¹íøena pod licencí Apache 2.0 a je ji tedy mo¾no pou¾ít pro komerèní úèely a distribuovat i s pøípadnými zmìnami.

			Pou¾itím tøídy odpadá nutnost pou¾ívat struktury roz¹íøení Zend enginu, které popisuji v kapitole \ref{integrateToPhp} a je mo¾né pou¾ít objektovou abstrakci. Dále umo¾òuje volání vestavìných funkcí PHP interpretru a není tedy potøeba jejich reimplementace. Volané funkce jsou v  interpretru PHP implementovány v jazyce C s èastým pou¾itím inline assembleru pro vysokou optimalizaci. Jejich voláním tedy nedochází k zpomalení. Dal¹í, podstatnìj¹í výhodou je mo¾nost pou¾ít tøídu \function{Php::Value}, která  implementuje pøetí¾ený konstruktor a pøetí¾ené operátory pro vìt¹inu datových typù a operací vèetnì porovnání s automatickou konverzí a implementuje i funkcionalitu polí.

			Nevýhodou tohoto øe¹ení je v¹ak jeho pomalost. Tøída \function{Php::Value} je internì velmi provázána s Zend enginem a pro vnitøní ulo¾ení dat jsou pou¾ity tzv. \function{zval} struktury, které vnitønì pou¾ívá i PHP interpret.\cite{PhpCppVariables} Ty obsahují mimo jiné i informace pro fungování garbage collectoru a tak, i kdy¾ nejsou tyto informace v kompilovaném kódu pou¾ity pro správu pamìti, konzumuje jejich generování procesorový èas.\cite{phpZvals} Z tohoto dùvodu, pokud je to mo¾né, není tato tøída pou¾ita pro promìnné a jsou pou¾ity primitivní datové typy \function{bool}, \function{long}, \function{double} a \function{std::string}.

		%\subsection{Tracy}
		%	Pro ladìní a error logy


	\section{Analýza zdrojových kódù PHP}
		Pro analýzu je tøeba provést parsování zdrojových kódù do abstraktní struktury. Pro tento krok je mo¾né pou¾ít funkce, které PHP nabízí. Konkrétnì se jedná o~funkci \function{token\_get()} vracející tokeny uvedené v~dokumentaci na adrese \url{http://php.net/manual/en/tokens.php}.

		Pøi programování se v¹ak ukázalo, ¾e tato funkce není dostateènì konkrétní pro zamý¹lené potøeby implementace. Èastým problémem bylo oznaèení velkého mno¾ství konstrukcí tokenem \function{T\_STRING}. Napøíklad v tabulce tokenù \ref{table:phpTokenExpresion} na stranì \pageref{table:phpTokenExpresion} nejsou uvedeny operátory +, -, /, * a dal¹í. To není z dùvodu jejich absence ve zvolené podmno¾inì, ale absencí konkrétních tokenù. V tabulce priority operátorù \ref{table:phpPrecendenceTable} jsou uvedeny a jsou dle ní pøekládány. Jeliko¾ výrazy jsou dùle¾itou èástí, tak byla doplnìna dal¹í úroveò abstrakce, která tyto tokeny pøeznaèí z \function{T\_STRING} na odpovídající vlastní tokeny - \function{T\_PLUS}, \function{T\_MUL} apod. Obdobný postup byl zvolen u dal¹ích chybìjících typù tokenù pro støedník, slo¾ené závorky a dal¹í.

		Po získání tìchto tokenù ze zdrojového kódu se pokraèuje jejich analýzou. V prùbìhu analýzy mù¾e být nalezena jedna z konstrukcí \function{include}, \function{include\_once}, \function{require}, \function{require\_once}. Pokud je mo¾né v dobì pøekladu získat cestu k souboru (tedy neobsahuje napøíklad promìnné), tak je provedeno jejich vlo¾ení - získání tokenù a vlo¾ení na odpovídající místo ji¾ známých tokenù. V pøípadì, ¾e není mo¾né provést vlo¾ení je druh vyvolané chyby obdobný jako v dobì interpretace. Konstrukce \function{include} a \function{include\_once} vedou pouze k vypsání chyby na standartní chybový výstup a pokraèuje se v pøikladu, kde¾to u \function{require} a \function{require\_once} je kromì výstupu také ukonèen pøeklad\cite{PhpRequire}.

		Vlastní parser vyu¾ívá metody rekurzivního sestupu zhora dolù. Pøi prùchodu sestavuje abstraktní syntaktický strom. Kdy¾ narazí na výraz, tak je pou¾ita zásobníková precedenèní analýza. Její derivaèní strom, který je výstupem, je pak opìt pøeveden na abstraktní syntaktický strom a zaèlenìn do stromu vzniklého v parseru.

		Pro ulo¾ení informací o promìnných - datové typy, pou¾ití apod. jsou pou¾ity instance tøídy \function{Variable} ulo¾ené v kontejneru, který tvoøí instance tøídy \function{Scope}. Informace jsou získávány z výstupu precedenèní analýzy, jeliko¾ v PHP mù¾e být pou¾ita promìnná ve výrazu i bez definice. Pak dojde, v zásvilosti na konfiguraci, k vypsání varování a hodnota takové promìnné je rovna \function{NULL}.

		Po dokonèení parsování tokenù zdrojového kódu je pøedáno øízení analyzátoru, který provádí detekci datových typù. Této detekci se podrobnìji vìnuji v následující podkapitole \ref{dataTypeDetection}.

		\begin{figure}[h]
		\centering
			\includesvg[svgpath = img/]{analyse}
			\caption{®ivotní cyklus roz¹íøení}
			\label{PhpAnalyse}
		\end{figure}

	\section{Detekce datových typù}
		\label{dataTypeDetection}
		Detekce datových typù je zalo¾ena na

	\section{Generování kódu}


	\section{Omezení}
		...

\chapter{Testování}
	...

	\section{Výkon}
		...

%\chapter{Optimalizace}
%	... V~závislosti na èasu experimentovat s~optimalizacemi konstrukcí
%
%\chapter{Detekce bezpeènostních chyb}
%	... Mo¾ná, v~závislosti na èasu
%
%	\section{Include injection}
%		... detekce konstrukcí jako include \$\_GET['page']
%
%	\section{XSS - Cross site scripting}
%		...







